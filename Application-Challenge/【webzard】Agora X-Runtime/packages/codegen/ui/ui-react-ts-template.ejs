import React from 'react';
import { CombinedError } from "urql";
import { useForm } from "react-hook-form";
import { renderer } from "../renderer";
import { <%- componentImports.join(', ') %> } from '@chakra-ui/react';
import { <%- dataImports.join(', ') %> } from "./data-components";

export const Error: React.FC<{ error: CombinedError }> = ({ error }) => {
  return (
    <Center>
      <Popover trigger="hover">
        <PopoverTrigger><Text>{error.message}</Text></PopoverTrigger>
        <PopoverContent>
          <PopoverCloseButton />
          <PopoverHeader>Error Detail:</PopoverHeader>
          <PopoverBody>
            <pre style={{ overflow: "auto" }}>
              {JSON.stringify(
                {
                  ...error,
                  networkError: {
                    message: error.networkError?.message,
                    stack: error.networkError?.stack,
                  },
                },
                null,
                2
              )}
            </pre>
          </PopoverBody>
        </PopoverContent>
      </Popover>
    </Center>
  );
};
export const Empty: React.FC<{ message?: string }> = ({ message = "no data" }) => {
  return <Center>{message}</Center>;
};

// table
<% for (table of views.table) { -%>
export const <%- table.componentName %>: React.FC = () => {
  const [{ data, fetching, error }] = <%- table.dataHook %>();
  if (error) {
    return <Error error={error} />;
  }
  if (fetching) {
    return (
      <Center>
        <Spinner />
      </Center>
    );
  }
  if (!data) {
    return <Empty />;
  }

  return (
    <Table variant="striped">
      <Thead>
        <Tr>
          <% for (const selection of table.selections) { -%>
          <Th><%- selection.name %></Th>
          <% } -%>
        </Tr>
      </Thead>
      <Tbody>
        {(data.<%- table.selectionName %> || []).map((entity) => {
          return (
            <Tr key={entity.<%- table.idName %>}>
              <% for (const selection of table.selections) { -%>
              <Td>{entity.<%- selection.name %>}</Td>
              <% } -%>
            </Tr>
          );
        })}
      </Tbody>
    </Table>
  );
};

<% } -%>

// list
<% for (list of views.list) { -%>
export const <%- list.componentName %>: React.FC = () => {
  const [{ data, fetching, error }] = <%- list.dataHook %>();
  if (error) {
    return <Error error={error} />;
  }
  if (fetching) {
    return (
      <Center>
        <Spinner />
      </Center>
    );
  }
  if (!data) {
    return <Empty />;
  }

  return (
    <List borderWidth="1px" rounded="md">
      {(data.<%- list.selectionName %> || []).map((entity) => {
        return (
          <ListItem key={entity.<%- list.idName %>} display="flex" justifyContent="space-between" p="6">
            <% for (const selection of list.selections) { -%>
            <Flex flex="1">{entity.<%- selection.name %>}</Flex>
            <% } -%>
          </ListItem>
        );
      })}
    </List>
  );
};

<% } -%>

// kanban
<% for (kanban of views.kanban) { -%>
export const <%- kanban.componentName %>: React.FC = () => {
  const [{ data, fetching, error }] = <%- kanban.dataHook %>();
  if (error) {
    return <Error error={error} />;
  }
  if (fetching) {
    return (
      <Center>
        <Spinner />
      </Center>
    );
  }
  if (!data) {
    return <Empty />;
  }

  return (
    <HStack spacing="6" align="flex-start">
      <% for (member of kanban.groupByEnum) { -%>
      <Box boxShadow="xs" rounded="md" p="6" flex="1">
        <Box><%- member %></Box>
        <VStack>
          {(data.<%- kanban.selectionName %> || [])
            .filter((entity) => entity.<%- kanban.groupByName %> === <%- kanban.groupByType %>.<%- common.capitalizeFirst(member) %>)
            .map((entity) => {
              return (
                <Box
                  width="full"
                  key={entity.<%- kanban.idName %>}
                  p={5}
                  shadow="md"
                  borderWidth="1px"
                  flex="1"
                  borderRadius="md"
                >
                  <% for (const selection of kanban.selections) { -%>
                  <Text mt={4}>{entity.<%- selection.name %>}</Text>
                  <% } -%>
                </Box>
              );
            })}
        </VStack>
      </Box>
      <% } -%>
    </HStack>
  );
};

<% } -%>

// form
<% for (form of views.form) { -%>
export type <%- form.componentName %>Values = {
  <% for (variable of form.variables) { -%>
  <%- variable.name %>: <%- variable.rawType %>;
  <% } -%>
};
export const <%- form.componentName %>: React.FC = () => {
  const [, trigger] = <%- form.dataHook %>();
  const {
    handleSubmit,
    register,
    formState: { errors, isSubmitting },
    reset,
  } = useForm<<%- form.componentName %>Values>();

  async function onSubmit(values: <%- form.componentName %>Values) {
    try {
      await trigger(values);
      reset();
    } catch (error) {

    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <% for (variable of form.variables) { -%>
        <% for (field of variable.flattenedFields) { -%>
          <FormControl isInvalid={Boolean(errors.<%- field.safePath %>)}>
            <FormLabel htmlFor="<%- field.path %>"><%- field.label %></FormLabel>
            <renderer.mutation.<%- field.baseType %>
              id="<%- field.path %>"
              <%- field.placeholder ? `placeholder="${field.placeholder}"` : '' %>
              {...register("<%- field.path %>", {
                <%- field.nullable ? '' : 'required: "This is required",' %>
                <%- ["Int", "Float"].includes(field.baseType) ? 'valueAsNumber: true,' : '' %>
              })}
              <%- field.baseType === 'Enum' ? `options={${enumOptionsRawMap[field.customType]}}` : ''  %>
            />
            <FormErrorMessage>
              {errors.<%- field.safePath %> && errors.<%- field.path %>.message}
            </FormErrorMessage>
          </FormControl>
        <% } -%>
      <% } -%>
      <Button
        mt={4}
        isLoading={isSubmitting}
        type="submit"
      >
        Submit
      </Button>
    </form>
  );
};

<% } -%>

// button
<% for (button of views.button) { -%>
export type <%- button.componentName %>Props = <%- button.variables.find(variable => variable.name === 'props').rawType %>;
export const <%- button.componentName %>: React.FC<<%- button.componentName %>Props> = (_props) => {
  const props = Object.assign(
    <%- common.formatRawProps(button.variables) %>,
    _props
  );
  return <Button {...props} />;
}
<% } -%>